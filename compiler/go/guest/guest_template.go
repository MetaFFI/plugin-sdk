package guest

const GuestHeaderTemplate = `
// Code generated by MetaFFI. Modify only in marked places.
// Guest code for {{.IDLFilenameWithExtension}}

package main
`

const GuestImportsTemplate = `
import "fmt"
import "unsafe"
import "reflect"
import "runtime"
import "github.com/MetaFFI/sdk/idl_entities/go/IDL"
import . "github.com/MetaFFI/sdk/api/go/metaffi"
{{range $mindex, $i := .Imports}}
import . "{{$i}}"{{end}}

{{range $mindex, $m := .Modules}}
{{range $eindex, $e := $m.ExternalResources}}
import "{{$e}}"{{end}}{{end}}

`

const GuestCImportCGoFileTemplate = `
package main

/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I"{{GetEnvVar "METAFFI_HOME" true}}"


#include <include/cdt.h>

// Provide C stub for metaffi_logf/metaffi_logfv/metaffi_log.
// These are declared in utils/logger_c.h (included by xllr_capi_loader.c)
// but implemented in C++. The guest DLL is built with CGo which cannot link C++,
// so we provide simple stderr-based stubs here.
#include <stdio.h>
#include <stdarg.h>

void metaffi_logfv(const char* component, int level, const char* fmt, va_list args) {
	fprintf(stderr, "[%s] ", component);
	vfprintf(stderr, fmt, args);
	fprintf(stderr, "\n");
}

void metaffi_logf(const char* component, int level, const char* fmt, ...) {
	va_list args;
	va_start(args, fmt);
	metaffi_logfv(component, level, fmt, args);
	va_end(args);
}

void metaffi_log(const char* component, int level, const char* message) {
	fprintf(stderr, "[%s] %s\n", component, message);
}

#include <include/xllr_capi_loader.c>

{{/* TODO: Do this without item CGo https://stackoverflow.com/questions/53238602/accessing-c-array-in-golang*/}}
metaffi_size get_int_item(metaffi_size* array, int index)
{
	return array[index];
}

{{/* TODO: Do this without item CGo https://stackoverflow.com/questions/53238602/accessing-c-array-in-golang*/}}
void* convert_union_to_ptr(void* p)
{
	return p;
}

{{/* TODO: Do this without item CGo https://stackoverflow.com/questions/53238602/accessing-c-array-in-golang*/}}
void set_cdt_type(struct cdt* p, metaffi_type t)
{
	p->type = t;
}

{{/* TODO: Do this without item CGo https://stackoverflow.com/questions/53238602/accessing-c-array-in-golang*/}}
metaffi_type get_cdt_type(struct cdt* p)
{
	return p->type;
}

{{/* TODO: Do this without item CGo https://stackoverflow.com/questions/53238602/accessing-c-array-in-golang*/}}
struct cdt* get_cdt_element(struct cdts* pdata, int cdts_index)
{
	return pdata[cdts_index].arr;
}

metaffi_handle get_null_handle()
{
	return METAFFI_NULL_HANDLE;
}

#ifdef _WIN32
metaffi_size len_to_metaffi_size(long long i)
#else
metaffi_size len_to_metaffi_size(long long i)
#endif
{
	return (metaffi_size)i;
}

*/
import "C"
`

const GuestCImportTemplate = `
/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I"{{GetEnvVar "METAFFI_HOME" true}}"

#include <include/cdt.h>
#include <include/xllr_capi_loader.h>

metaffi_size get_int_item(metaffi_size* array, int index);
void* convert_union_to_ptr(void* p);
void set_cdt_type(struct cdt* p, metaffi_type t);
metaffi_type get_cdt_type(struct cdt* p);

struct cdt* get_cdt_element(struct cdts* pdata, int cdts_index);
metaffi_handle get_null_handle();

#ifdef _WIN32
	metaffi_size len_to_metaffi_size(long long i);
#else
	metaffi_size len_to_metaffi_size(long long i);
#endif
*/
import "C"
`

const GuestMainFunction = `
func main(){} // main function must be declared to create dynamic library
func init(){
	err := C.load_xllr()
	if err != nil{
		panic("Failed to load MetaFFI XLLR functions: "+C.GoString(err))
	}

}
`

const GuestHelperFunctionsTemplate = `

func errToOutError(out_err **C.char, customText string, err error){
	txt := customText
	if err != nil { txt += err.Error() }
	goCString := C.CString(txt)
	defer C.free(unsafe.Pointer(goCString))
	*out_err = C.xllr_alloc_string(goCString, C.uint64_t(len(txt)))
}

func panicHandler(out_err **C.char){
	if rec := recover(); rec != nil{
		msg := "Panic in Go function. Panic Data: "
		switch recType := rec.(type){
		case error:
			msg += (rec.(error)).Error()
		case string:
			msg += rec.(string)
		default:
			msg += fmt.Sprintf("Panic with type: %v - %v", recType, rec)
		}

		// Add stack trace to message
		stack := make([]byte, 1024*8)
		stack = stack[:runtime.Stack(stack, false)]
		msg = fmt.Sprintf("%s\nStack Trace:\n%s", msg, string(stack))

		goCString := C.CString(msg)
		defer C.free(unsafe.Pointer(goCString))
		*out_err = C.xllr_alloc_string(goCString, C.uint64_t(len(msg)))
	}
}

`

const (
	GuestFunctionXLLRTemplate = `
{{$def := .}}
var dummyreflect reflect.Type
{{range $mindex, $m := .Modules}}

{{range $findex, $f := $m.Globals}}
{{if $f.Getter}}
// getter for {{$f.Name}}
//export EntryPoint_{{$f.Getter.Name}} 
func EntryPoint_{{GenerateCodeEntryPointSignature "" $f.Getter.Name $f.Getter.Parameters $f.Getter.ReturnValues}}{

	// catch panics and return them as errors
	defer panicHandler(out_err)

	{{ $paramsLength := len $f.Getter.Parameters }}{{ $returnLength := len $f.Getter.ReturnValues }}

	retvals_CDTS := C.get_cdt_element(xcall_params, {{GetCDTReturnValueIndex $f.Getter.Parameters $f.Getter.ReturnValues}})
	t0 := IDL.MetaFFITypeInfo{ {{$t := index $f.Getter.ReturnValues 0}}
	    StringType: "{{$t.Type}}",
	    Alias:"{{$t.TypeAlias}}",
	    Dimensions: {{$t.Dimensions}},
		Type: {{GetMetaFFINumericType $t.Type}},
	}
	FromGoToCDT({{$f.Name}}, unsafe.Pointer(retvals_CDTS), t0, 0)

}
{{end}} {{/* end $f.Get */}}

{{if $f.Setter}}
// setter for {{$f.Name}}
//export EntryPoint_{{$f.Setter.Name}}
func EntryPoint_{{GenerateCodeEntryPointSignature "" $f.Setter.Name $f.Setter.Parameters $f.Setter.ReturnValues}}{

	// catch panics and return them as errors
	defer panicHandler(out_err)

	{{ $paramsLength := len $f.Setter.Parameters }}{{ $returnLength := len $f.Setter.ReturnValues }}

	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	{{$elem := index $f.Setter.Parameters 0}}
	_globalSetValAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, {{GetTypeForCDTToGo $elem $m}})
	{{$f.Name}} = {{ConvertGlobalSetterExpression $elem $m}}
}
{{end}} {{/* end $f.Set */}}

{{end}} {{/* end range globals */}}


// functions
{{range $findex, $f := $m.Functions}}
// Call to foreign {{$f.Name}}
//export EntryPoint_{{$f.Name}}
func EntryPoint_{{GenerateCodeEntryPointSignature "" $f.Name $f.Parameters $f.ReturnValues}}{
	// catch panics and return them as errors
	defer panicHandler(out_err)

	{{ $paramsLength := len $f.Parameters }}{{ $returnLength := len $f.ReturnValues }}

	{{ if gt $paramsLength 0 }}
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	{{end}}
	{{ if gt $returnLength 0 }}
	retvals_CDTS := C.get_cdt_element(xcall_params, {{GetCDTReturnValueIndex $f.Parameters $f.ReturnValues}})
	{{end}}

	// parameters from C to Go
	{{range $index, $elem := $f.Parameters}}
	{{$elem.Name}}AsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), {{$index}}, {{GetTypeForCDTToGo $elem $m}})
	{{ConvertEmptyInterfaceFromCDTSToCorrectType $elem $m false}}
	{{end}} {{/* end range params */}}
	
	// call original function
	{{$hasErrorReturn := index $f.Tags "has_error_return"}}
	{{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{$elem.Name}}{{end}}{{if and (not $f.ReturnValues) (eq $hasErrorReturn "true")}}errReturn_{{else if eq $hasErrorReturn "true"}},errReturn_{{end}}{{if or $f.ReturnValues (eq $hasErrorReturn "true")}} := {{end}}{{$f.Name}}({{CallParameters $f 0}})

	{{if eq $hasErrorReturn "true"}}
	if errReturn_ != nil {
		errToOutError(out_err, "Error returned: ", errReturn_)
		return
	}
	{{end}}
	
	// return values
	{{range $index, $elem := $f.ReturnValues}}
	if err, isError := interface{}({{$elem.Name}}).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t{{$index}} := IDL.MetaFFITypeInfo{   {{$t := index $f.ReturnValues $index}}
			StringType: "{{$t.Type}}",
			Alias:"{{$t.TypeAlias}}",
			Dimensions: {{$t.Dimensions}},
			Type: {{GetMetaFFINumericType $t.Type}},
		}
		FromGoToCDT({{$elem.Name}}, unsafe.Pointer(retvals_CDTS), t{{$index}}, {{$index}})
	}	
	{{end}} {{/* end range return vals */}}
}
{{end}} {{/* end range functions */}}


{{range $cindex, $c := $m.Classes}}
// class {{$c.Name}}
{{$className := $c.Name}}

{{$isInterface := index $c.Tags "interface"}}
{{if ne $isInterface "true"}}
// return empty struct
//export EntryPoint_{{$c.Name}}_EmptyStruct_MetaFFI
func EntryPoint_{{GenerateCodeEntryPointEmptyStructSignature $c.Name}}{
	instance := &{{$c.Name}}{}
	FromGoToCDT(instance, unsafe.Pointer(C.get_cdt_element(xcall_params, 0)), IDL.MetaFFITypeInfo{ StringType: IDL.HANDLE, Dimensions: 0, Type: {{GetMetaFFINumericType "handle"}} }, 0)
}
{{end}}

// constructors
{{range $i, $f := $c.Constructors}}
// Call to foreign {{$f.Name}}
//export EntryPoint_{{$c.Name}}_{{$f.Name}}
func EntryPoint_{{GenerateCodeEntryPointSignature $c.Name $f.Name $f.Parameters $f.ReturnValues}}{
	// catch panics and return them as errors
	defer panicHandler(out_err)

	{{ $paramsLength := len $f.Parameters }}{{ $returnLength := len $f.ReturnValues }}
	
	{{ if gt $paramsLength 0 }}
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	{{end}}
	{{ if gt $returnLength 0 }}
	retvals_CDTS := C.get_cdt_element(xcall_params, {{GetCDTReturnValueIndex $f.Parameters $f.ReturnValues}})
	{{end}}

	// parameters from C to Go
	{{range $index, $elem := $f.Parameters}}	
	{{$elem.Name}}AsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), {{$index}}, {{GetTypeForCDTToGo $elem $m}})
	{{ConvertEmptyInterfaceFromCDTSToCorrectType $elem $m false}}
	{{end}} {{/* end range params */}}
	
	// call original function
	{{$hasErrorReturn := index $f.Tags "has_error_return"}}
	{{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{$elem.Name}}{{end}}{{if and (not $f.ReturnValues) (eq $hasErrorReturn "true")}}errReturn_{{else if eq $hasErrorReturn "true"}},errReturn_{{end}}{{if or $f.ReturnValues (eq $hasErrorReturn "true")}} := {{end}}{{$f.Name}}({{CallParameters $f.FunctionDefinition 0}})

	{{if eq $hasErrorReturn "true"}}
	if errReturn_ != nil {
		errToOutError(out_err, "Error returned: ", errReturn_)
		return
	}
	{{end}}
	
	// return values
	{{range $index, $elem := $f.ReturnValues}}
	if err, isError := interface{}({{$elem.Name}}).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t{{$index}} := IDL.MetaFFITypeInfo{ {{$t := index $f.ReturnValues $index}}
			StringType: "{{$t.Type}}",
			Alias:"{{$t.TypeAlias}}",
			Dimensions: {{$t.Dimensions}},
			Type: {{GetMetaFFINumericType $t.Type}},
		}
		FromGoToCDT({{$elem.Name}}, unsafe.Pointer(retvals_CDTS), t{{$index}}, {{$index}})
	}	
	{{end}} {{/* end range return vals */}}
}
{{end}} {{/* end range constructors */}}

// methods
{{range $i, $f := $c.Methods}}
// Call to foreign {{$f.Name}}
//export EntryPoint_{{$c.Name}}_{{$f.Name}}
func EntryPoint_{{GenerateCodeEntryPointSignature $c.Name $f.Name $f.Parameters $f.ReturnValues}}{
	// catch panics and return them as errors
	defer panicHandler(out_err)

	{{ $paramsLength := len $f.Parameters }}{{ $returnLength := len $f.ReturnValues }}
	
	{{ if gt $paramsLength 0 }}
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	{{end}}
	{{ if gt $returnLength 0 }}
	retvals_CDTS := C.get_cdt_element(xcall_params, {{GetCDTReturnValueIndex $f.Parameters $f.ReturnValues}})
	{{end}}

	// parameters from C to Go
	{{range $index, $elem := $f.Parameters}}	
	{{$elem.Name}}AsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), {{$index}}, {{GetTypeForCDTToGo $elem $m}})
	{{ConvertEmptyInterfaceFromCDTSToCorrectType $elem $m false}}
	{{end}} {{/* end range params */}}
	
	// call original function (method receiver must be first parameter; IDL adds this_instance for methods)
	{{ $receiver_pointer := index $f.Tags "receiver_pointer"}}
	{{$hasErrorReturn := index $f.Tags "has_error_return"}}
	{{if $f.Parameters}}
	{{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{$elem.Name}}{{end}}{{if and (not $f.ReturnValues) (eq $hasErrorReturn "true")}}errReturn_{{else if eq $hasErrorReturn "true"}},errReturn_{{end}}{{if or $f.ReturnValues (eq $hasErrorReturn "true")}} := {{end}}({{(index $f.Parameters 0).Name }}.({{if eq $receiver_pointer "true"}}*{{end}}{{$className}})).{{$f.Name}}({{ CallParameters $f.FunctionDefinition 1}})
	{{else}}
	panic("MetaFFI: method {{$c.Name}}.{{$f.Name}} has no receiver (IDL must set instance_required for methods; rebuild go_idl_compiler)")
	return
	{{end}}

	{{if eq $hasErrorReturn "true"}}
	if errReturn_ != nil {
		errToOutError(out_err, "Error returned: ", errReturn_)
		return
	}
	{{end}}

	// return values
	{{range $index, $elem := $f.ReturnValues}}
	if err, isError := interface{}({{$elem.Name}}).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t{{$index}} := IDL.MetaFFITypeInfo{   {{$t := index $f.ReturnValues $index}}
			StringType: "{{$t.Type}}",
			Alias:"{{$t.TypeAlias}}",
			Dimensions: {{$t.Dimensions}},
			Type: {{GetMetaFFINumericType $t.Type}},
		}
		FromGoToCDT({{$elem.Name}}, unsafe.Pointer(retvals_CDTS), t{{$index}}, {{$index}})
	}	
	{{end}} {{/* end range return values */}}
}
{{end}} {{/* end range methods */}}

// Fields
{{range $i, $f := $c.Fields}}
{{if $f.Getter}}
// getter for {{$f.Name}}
//export EntryPoint_{{$c.Name}}_{{$f.Getter.Name}}
func EntryPoint_{{GenerateCodeEntryPointSignature $c.Name $f.Getter.Name $f.Getter.Parameters $f.Getter.ReturnValues}}{

	// catch panics and return them as errors
	defer panicHandler(out_err)
	{{ $paramsLength := len $f.Getter.Parameters }}{{ $returnLength := len $f.Getter.ReturnValues }}

	{{ if gt $paramsLength 0 }}
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	{{end}}
	{{ if gt $returnLength 0 }}
	retvals_CDTS := C.get_cdt_element(xcall_params, {{GetCDTReturnValueIndex $f.Getter.Parameters $f.Getter.ReturnValues}})
	{{end}}

	// get object
	{{ $elem := index $f.Getter.Parameters 0 }}
	objAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, {{GetTypeForCDTToGo $elem $m}})
	obj := {{if not $elem.IsAny}}{{SafeTypeForAssertion $elem $m}}({{end}}objAsInterface{{if not $elem.IsAny}}.({{SafeTypeForAssertion $elem $m}})){{end}}

	{{ $receiver_pointer := index $f.Getter.Tags "receiver_pointer"}}
	{{$f.Name}}_res := obj.({{if eq $receiver_pointer "true"}}*{{end}}{{$className}}).{{$f.Name}}

	{{ if gt $returnLength 0 }}
	t0 := IDL.MetaFFITypeInfo{ {{$t := index $f.Getter.ReturnValues 0}}
		StringType: "{{$t.Type}}",
		Alias:"{{$t.TypeAlias}}",
		Dimensions: {{$t.Dimensions}},
		Type: {{GetMetaFFINumericType $t.Type}},
	}
	FromGoToCDT({{$f.Name}}_res, unsafe.Pointer(retvals_CDTS), t0, 0)
	{{end}}
}
{{end}} {{/* end $f.Getter */}}

{{if $f.Setter}}
// setter for {{$f.Name}}
//export EntryPoint_{{$c.Name}}_{{$f.Setter.Name}}
func EntryPoint_{{GenerateCodeEntryPointSignature $c.Name $f.Setter.Name $f.Setter.Parameters $f.Setter.ReturnValues}}{

	// catch panics and return them as errors
	defer panicHandler(out_err)

	{{ $paramsLength := len $f.Setter.Parameters }}{{ $returnLength := len $f.Setter.ReturnValues }}

	{{ if gt $paramsLength 0 }}
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	{{end}}
	{{ if gt $returnLength 0 }}
	retvals_CDTS := C.get_cdt_element(xcall_params, {{GetCDTReturnValueIndex $f.Setter.Parameters $f.Setter.ReturnValues}})
	{{end}}

	// get object
	{{ $elem := index $f.Setter.Parameters 0 }}
	thisAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, {{GetTypeForCDTToGo $elem $m}})
	this := {{if not $elem.IsAny}}{{SafeTypeForAssertion $elem $m}}({{end}}thisAsInterface{{if not $elem.IsAny}}.({{SafeTypeForAssertion $elem $m}})){{end}}

	// get val
	{{ $elem = index $f.Setter.Parameters 1 }}
	{{$elem.Name}}AsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 1, {{GetTypeForCDTToGo $elem $m}})
	{{ConvertEmptyInterfaceFromCDTSToCorrectType $elem $m false}}
	
	// set new data (always use pointer assertion for setters - value assertions are non-addressable in Go)
	this.(*{{$className}}).{{$f.Name}} = {{$elem.Name}}
	
}
{{end}}{{/* end $f.Setter */}}

{{end}} {{/* end range fields */}}

// end class {{$c.Name}}
{{end}} {{/* end range classes */}}

{{end}} {{/* end range modules */}}

`
)
