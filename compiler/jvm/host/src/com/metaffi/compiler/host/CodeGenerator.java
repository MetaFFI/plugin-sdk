
package com.metaffi.compiler.host;

import com.metaffi.idl.entities.ArgDefinition;
import com.metaffi.idl.entities.ClassDefinition;
import com.metaffi.idl.entities.ConstructorDefinition;
import com.metaffi.idl.entities.FieldDefinition;
import com.metaffi.idl.entities.FunctionDefinition;
import com.metaffi.idl.entities.GlobalDefinition;
import com.metaffi.idl.entities.IDLDefinition;
import com.metaffi.idl.entities.MethodDefinition;
import com.metaffi.idl.entities.ModuleDefinition;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class CodeGenerator {
    private final TypeInfoGenerator typeInfoGenerator;

    public CodeGenerator(TypeInfoGenerator typeInfoGenerator) {
        if (typeInfoGenerator == null) {
            throw new CompilerException("TypeInfoGenerator is required");
        }
        this.typeInfoGenerator = typeInfoGenerator;
    }

    public String generateModuleCode(ModuleDefinition module, IDLDefinition definition, String packageName, String className) {
        if (module == null) {
            throw new CompilerException("ModuleDefinition is required");
        }
        if (definition == null) {
            throw new CompilerException("IDLDefinition is required");
        }
        if (className == null || className.isEmpty()) {
            throw new CompilerException("className is required");
        }

        StringBuilder sb = new StringBuilder();
        sb.append("// Code generated by MetaFFI. DO NOT EDIT.\n");
        sb.append("// Host code for ").append(definition.getIdlFilenameWithExtension()).append("\n\n");

        if (packageName != null && !packageName.isEmpty()) {
            sb.append("package ").append(packageName).append(";\n\n");
        }

        sb.append("import api.MetaFFIModule;\n");
        sb.append("import api.MetaFFIRuntime;\n");
        sb.append("import metaffi.api.accessor.Caller;\n");
        sb.append("import metaffi.api.accessor.MetaFFITypeInfo;\n");
        sb.append("import metaffi.api.accessor.MetaFFITypeInfo.MetaFFITypes;\n");
        sb.append("import java.math.BigInteger;\n\n");

        appendLine(sb, 0, "public class " + className + " {");
        appendLine(sb, 1, "private static MetaFFIRuntime runtime;");
        appendLine(sb, 1, "private static MetaFFIModule module;");
        appendLine(sb, 0, "");

        List<String> callerDecls = new ArrayList<>();
        List<String> loadLines = new ArrayList<>();

        // Functions
        for (FunctionDefinition func : module.getFunctions()) {
            String callerName = callerName(func.getName(), "Caller");
            callerDecls.add("private static Caller " + callerName + ";");

            String entityPath = EntityPathConverter.functionEntityPathToString(func, definition);
            String params = typeInfoGenerator.generateTypeInfoArray(func.getParameters());
            String retvals = typeInfoGenerator.generateTypeInfoArray(func.getReturnValues());
            loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
        }

        // Globals
        for (GlobalDefinition globalDef : module.getGlobals()) {
            if (globalDef.getGetter() != null) {
                String callerName = callerName(globalDef.getName(), "GetterCaller");
                callerDecls.add("private static Caller " + callerName + ";");

                String entityPath = EntityPathConverter.globalEntityPathToString(globalDef, definition, true);
                String params = typeInfoGenerator.generateTypeInfoArray(globalDef.getGetter().getParameters());
                String retvals = typeInfoGenerator.generateTypeInfoArray(globalDef.getGetter().getReturnValues());
                loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
            }
            if (globalDef.getSetter() != null) {
                String callerName = callerName(globalDef.getName(), "SetterCaller");
                callerDecls.add("private static Caller " + callerName + ";");

                String entityPath = EntityPathConverter.globalEntityPathToString(globalDef, definition, false);
                String params = typeInfoGenerator.generateTypeInfoArray(globalDef.getSetter().getParameters());
                String retvals = typeInfoGenerator.generateTypeInfoArray(globalDef.getSetter().getReturnValues());
                loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
            }
        }

        // Classes
        for (ClassDefinition cls : module.getClasses()) {
            // Constructors
            for (ConstructorDefinition ctor : cls.getConstructors()) {
                String callerName = callerName(cls.getName() + "_" + ctor.getName(), "Caller");
                callerDecls.add("private static Caller " + callerName + ";");

                String entityPath = EntityPathConverter.constructorEntityPathToString(ctor, definition);
                String params = typeInfoGenerator.generateTypeInfoArray(ctor.getParameters());
                String retvals = typeInfoGenerator.generateTypeInfoArray(ctor.getReturnValues());
                loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
            }

            // Release
            if (cls.getRelease() != null) {
                String callerName = callerName(cls.getName() + "_release", "Caller");
                callerDecls.add("private static Caller " + callerName + ";");

                String entityPath = EntityPathConverter.methodEntityPathToString(cls.getRelease(), definition, cls.getEntityPath());
                String params = typeInfoGenerator.generateTypeInfoArray(cls.getRelease().getParameters());
                String retvals = typeInfoGenerator.generateTypeInfoArray(cls.getRelease().getReturnValues());
                loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
            }

            // Methods
            for (MethodDefinition method : cls.getMethods()) {
                String callerName = callerName(cls.getName() + "_" + method.getName(), "Caller");
                callerDecls.add("private static Caller " + callerName + ";");

                String entityPath = EntityPathConverter.methodEntityPathToString(method, definition, cls.getEntityPath());
                String params = typeInfoGenerator.generateTypeInfoArray(method.getParameters());
                String retvals = typeInfoGenerator.generateTypeInfoArray(method.getReturnValues());
                loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
            }

            // Fields
            for (FieldDefinition field : cls.getFields()) {
                if (field.getGetter() != null) {
                    String callerName = callerName(cls.getName() + "_" + field.getName(), "GetterCaller");
                    callerDecls.add("private static Caller " + callerName + ";");

                    String entityPath = EntityPathConverter.fieldEntityPathToString(field, definition, cls.getEntityPath(), true);
                    String params = typeInfoGenerator.generateTypeInfoArray(field.getGetter().getParameters());
                    String retvals = typeInfoGenerator.generateTypeInfoArray(field.getGetter().getReturnValues());
                    loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
                }
                if (field.getSetter() != null) {
                    String callerName = callerName(cls.getName() + "_" + field.getName(), "SetterCaller");
                    callerDecls.add("private static Caller " + callerName + ";");

                    String entityPath = EntityPathConverter.fieldEntityPathToString(field, definition, cls.getEntityPath(), false);
                    String params = typeInfoGenerator.generateTypeInfoArray(field.getSetter().getParameters());
                    String retvals = typeInfoGenerator.generateTypeInfoArray(field.getSetter().getReturnValues());
                    loadLines.add(callerName + " = module.load(\"" + escapeJava(entityPath) + "\", " + params + ", " + retvals + ");");
                }
            }
        }

        for (String decl : callerDecls) {
            appendLine(sb, 1, decl);
        }
        appendLine(sb, 0, "");

        appendLine(sb, 1, "public static void bindModuleToCode(String modulePath, String runtimePlugin) {");
        appendLine(sb, 2, "if (modulePath == null || modulePath.isEmpty()) {");
        appendLine(sb, 3, "throw new IllegalArgumentException(\"modulePath is required\");");
        appendLine(sb, 2, "}");
        appendLine(sb, 2, "if (runtimePlugin == null || runtimePlugin.isEmpty()) {");
        appendLine(sb, 3, "throw new IllegalArgumentException(\"runtimePlugin is required\");");
        appendLine(sb, 2, "}");
        appendLine(sb, 2, "runtime = new MetaFFIRuntime(runtimePlugin);");
        appendLine(sb, 2, "runtime.loadRuntimePlugin();");
        appendLine(sb, 2, "module = runtime.loadModule(modulePath);");
        appendLine(sb, 0, "");
        appendLine(sb, 2, "// Load and cache all entities");
        for (String loadLine : loadLines) {
            appendLine(sb, 2, loadLine);
        }
        appendLine(sb, 1, "}");
        appendLine(sb, 0, "");

        List<String> wrapperClasses = new ArrayList<>();
        Set<String> wrapperClassNames = new HashSet<>();

        // Function stubs
        for (FunctionDefinition func : module.getFunctions()) {
            generateFunctionStubs(sb, func, className, wrapperClassNames, wrapperClasses);
            appendLine(sb, 0, "");
        }

        // Globals accessors
        for (GlobalDefinition globalDef : module.getGlobals()) {
            appendLine(sb, 0, generateGlobalAccessors(globalDef, className));
            appendLine(sb, 0, "");
        }

        // Classes
        for (ClassDefinition cls : module.getClasses()) {
            appendLine(sb, 0, generateClassDefinition(cls, className, wrapperClassNames, wrapperClasses));
            appendLine(sb, 0, "");
        }

        // Result wrapper classes
        for (String wrapper : wrapperClasses) {
            appendLine(sb, 1, wrapper);
            appendLine(sb, 0, "");
        }

        appendLine(sb, 0, "}");
        return sb.toString();
    }

    private void generateFunctionStubs(StringBuilder sb, FunctionDefinition func, String className,
                                       Set<String> wrapperClassNames, List<String> wrapperClasses) {
        if (func == null) {
            return;
        }
        String returnType = getReturnType(func.getReturnValues(), className, wrapperClassNames, wrapperClasses,
            null, func.getName());
        String paramsSig = buildParamSignature(func.getParameters(), 0);
        String callerName = callerName(func.getName(), "Caller");

        appendJavaDoc(sb, 1, func.getComment(), "Generated stub for " + func.getName());
        appendLine(sb, 1, "public static " + returnType + " " + func.getName() + "(" + paramsSig + ") {");
        appendLine(sb, 2, generateCallBody(func.getParameters(), 0, func.getReturnValues(), returnType, callerName, className));
        appendLine(sb, 1, "}");

        // Optional overloads
        appendOptionalOverloads(sb, func.getName(), func.getParameters(), 0, returnType, className, true);
    }

    private String generateGlobalAccessors(GlobalDefinition globalDef, String outerClassName) {
        StringBuilder sb = new StringBuilder();
        String type = mapToJavaType(globalDef.getType(), globalDef.getDimensions(), globalDef.getTypeAlias());

        if (globalDef.getGetter() != null) {
            String getterName = "get" + toPascalCase(globalDef.getName());
            String callerName = callerName(globalDef.getName(), "GetterCaller");
            appendJavaDoc(sb, 1, globalDef.getComment(), "Getter for global " + globalDef.getName());
            appendLine(sb, 1, "public static " + type + " " + getterName + "() {");
            appendLine(sb, 2, generateReturnBody(globalDef.getGetter().getReturnValues(), type, callerName, outerClassName));
            appendLine(sb, 1, "}");
        }

        if (globalDef.getSetter() != null) {
            if (globalDef.getGetter() != null) {
                appendLine(sb, 0, "");
            }
            String setterName = "set" + toPascalCase(globalDef.getName());
            String callerName = callerName(globalDef.getName(), "SetterCaller");
            appendJavaDoc(sb, 1, globalDef.getComment(), "Setter for global " + globalDef.getName());
            appendLine(sb, 1, "public static void " + setterName + "(" + type + " value) {");
            appendLine(sb, 2, callerName + ".call(value);");
            appendLine(sb, 1, "}");
        }

        return sb.toString();
    }
    private String generateClassDefinition(ClassDefinition cls, String outerClassName,
                                           Set<String> wrapperClassNames, List<String> wrapperClasses) {
        StringBuilder sb = new StringBuilder();
        appendJavaDoc(sb, 1, cls.getComment(), "Generated stub class for " + cls.getName());
        appendLine(sb, 1, "public static class " + cls.getName() + " implements AutoCloseable {");
        appendLine(sb, 2, "private Object handle;");
        appendLine(sb, 0, "");

        // Private constructor
        appendLine(sb, 2, "private " + cls.getName() + "(Object handle) {");
        appendLine(sb, 3, "this.handle = handle;");
        appendLine(sb, 2, "}");
        appendLine(sb, 0, "");

        // Constructors (factory methods)
        for (ConstructorDefinition ctor : cls.getConstructors()) {
            if (ctor.getReturnValues() == null || ctor.getReturnValues().size() != 1) {
                throw new CompilerException("Constructor " + ctor.getName() + " in class " + cls.getName() + " must return exactly one value");
            }

            String paramsSig = buildParamSignature(ctor.getParameters(), 0);
            String methodName = "create" + toPascalCase(ctor.getName());
            String callerName = callerName(cls.getName() + "_" + ctor.getName(), "Caller");

            appendJavaDoc(sb, 2, ctor.getComment(), "Factory for " + cls.getName());
            appendLine(sb, 2, "public static " + cls.getName() + " " + methodName + "(" + paramsSig + ") {");
            appendLine(sb, 3, generateConstructorBody(ctor.getParameters(), callerName, cls.getName()));
            appendLine(sb, 2, "}");

            // Optional overloads
            appendOptionalOverloads(sb, methodName, ctor.getParameters(), 0, cls.getName(), outerClassName, true, 2);
            appendLine(sb, 0, "");
        }

        // Methods
        for (MethodDefinition method : cls.getMethods()) {
            boolean isStatic = !method.isInstanceRequired();
            int paramStart = method.isInstanceRequired() ? 1 : 0;
            String returnType = getReturnType(method.getReturnValues(), outerClassName, wrapperClassNames, wrapperClasses,
                cls.getName(), method.getName());
            String paramsSig = buildParamSignature(method.getParameters(), paramStart);
            String callerName = callerName(cls.getName() + "_" + method.getName(), "Caller");

            appendJavaDoc(sb, 2, method.getComment(), "Generated stub method for " + method.getName());
            appendLine(sb, 2, (isStatic ? "public static " : "public ") + returnType + " " + method.getName() + "(" + paramsSig + ") {");
            appendLine(sb, 3, generateCallBody(method.getParameters(), paramStart, method.getReturnValues(), returnType,
                callerName, outerClassName, method.isInstanceRequired()));
            appendLine(sb, 2, "}");

            // Optional overloads
            appendOptionalOverloads(sb, method.getName(), method.getParameters(), paramStart, returnType, outerClassName, isStatic, 2);
            appendLine(sb, 0, "");
        }

        // Fields
        for (FieldDefinition field : cls.getFields()) {
            String type = mapToJavaType(field.getType(), field.getDimensions(), field.getTypeAlias());
            String capitalized = toPascalCase(field.getName());

            if (field.getGetter() != null) {
                boolean isStatic = !field.getGetter().isInstanceRequired();
                String getterName = "get" + capitalized;
                String callerName = callerName(cls.getName() + "_" + field.getName(), "GetterCaller");
                appendJavaDoc(sb, 2, field.getComment(), "Getter for field " + field.getName());
                appendLine(sb, 2, (isStatic ? "public static " : "public ") + type + " " + getterName + "() {");
                appendLine(sb, 3, generateReturnBody(field.getGetter().getReturnValues(), type, callerName, outerClassName,
                    field.getGetter().isInstanceRequired()));
                appendLine(sb, 2, "}");
            }

            if (field.getSetter() != null) {
                if (field.getGetter() != null) {
                    appendLine(sb, 0, "");
                }
                boolean isStatic = !field.getSetter().isInstanceRequired();
                String setterName = "set" + capitalized;
                String callerName = callerName(cls.getName() + "_" + field.getName(), "SetterCaller");
                appendJavaDoc(sb, 2, field.getComment(), "Setter for field " + field.getName());
                appendLine(sb, 2, (isStatic ? "public static " : "public ") + "void " + setterName + "(" + type + " value) {");
                if (field.getSetter().isInstanceRequired()) {
                    appendLine(sb, 3, callerName + ".call(this.handle, value);");
                } else {
                    appendLine(sb, 3, callerName + ".call(value);");
                }
                appendLine(sb, 2, "}");
            }

            appendLine(sb, 0, "");
        }

        // Release/close
        if (cls.getRelease() != null) {
            String callerName = callerName(cls.getName() + "_release", "Caller");
            appendLine(sb, 2, "@Override");
            appendLine(sb, 2, "public void close() {");
            appendLine(sb, 3, "if (this.handle != null) {");
            appendLine(sb, 4, callerName + ".call(this.handle);");
            appendLine(sb, 4, "this.handle = null;");
            appendLine(sb, 3, "}");
            appendLine(sb, 2, "}");
        }

        appendLine(sb, 1, "}");
        return sb.toString();
    }

    private String generateCallBody(List<ArgDefinition> params, int startIndex, List<ArgDefinition> retvals,
                                    String returnType, String callerName, String outerClassName) {
        return generateCallBody(params, startIndex, retvals, returnType, callerName, outerClassName, false);
    }

    private String generateCallBody(List<ArgDefinition> params, int startIndex, List<ArgDefinition> retvals,
                                    String returnType, String callerName, String outerClassName, boolean instanceRequired) {
        String args = buildCallerArgs(params, startIndex, instanceRequired);
        if (retvals == null || retvals.isEmpty()) {
            return callerName + ".call(" + args + ");";
        }

        StringBuilder body = new StringBuilder();
        body.append("Object[] result = ").append(callerName).append(".call(").append(args).append(");\n");
        body.append(indent(2)).append("return ").append(renderReturnValue(retvals, returnType, outerClassName, "result")).append(";");
        return body.toString();
    }

    private String generateReturnBody(List<ArgDefinition> retvals, String returnType, String callerName, String outerClassName) {
        return generateReturnBody(retvals, returnType, callerName, outerClassName, false);
    }

    private String generateReturnBody(List<ArgDefinition> retvals, String returnType, String callerName, String outerClassName, boolean instanceRequired) {
        String args = instanceRequired ? "this.handle" : "";
        if (retvals == null || retvals.isEmpty()) {
            return callerName + ".call(" + args + ");";
        }

        StringBuilder body = new StringBuilder();
        body.append("Object[] result = ").append(callerName).append(".call(").append(args).append(");\n");
        body.append(indent(2)).append("return ").append(renderReturnValue(retvals, returnType, outerClassName, "result")).append(";");
        return body.toString();
    }

    private String generateConstructorBody(List<ArgDefinition> params, String callerName, String className) {
        String args = buildCallerArgs(params, 0, false);
        StringBuilder body = new StringBuilder();
        body.append("Object[] result = ").append(callerName).append(".call(").append(args).append(");\n");
        body.append(indent(2)).append("return new ").append(className).append("(result[0]);");
        return body.toString();
    }

    private String renderReturnValue(List<ArgDefinition> retvals, String returnType, String outerClassName, String resultVar) {
        if (retvals == null || retvals.isEmpty()) {
            return "null";
        }
        if (retvals.size() == 1) {
            ArgDefinition rv = retvals.get(0);
            return convertExpression(rv, resultVar + "[0]");
        }

        String wrapperName = returnType;
        StringBuilder args = new StringBuilder();
        for (int i = 0; i < retvals.size(); i++) {
            if (i > 0) {
                args.append(", ");
            }
            args.append(convertExpression(retvals.get(i), resultVar + "[" + i + "]"));
        }
        return "new " + wrapperName + "(" + args + ")";
    }

    private String convertExpression(ArgDefinition arg, String expr) {
        String baseType = normalizeBaseType(arg.getType());
        int dims = normalizeDimensions(arg.getType(), arg.getDimensions());
        String javaType = mapToJavaType(arg.getType(), arg.getDimensions(), arg.getTypeAlias());

        if (dims > 0) {
            return "(" + javaType + ")" + expr;
        }

        switch (baseType) {
            case "int8":
                return "((Number)" + expr + ").byteValue()";
            case "uint8":
                return "((Number)" + expr + ").shortValue()";
            case "int16":
                return "((Number)" + expr + ").shortValue()";
            case "uint16":
                return "((Number)" + expr + ").intValue()";
            case "int32":
                return "((Number)" + expr + ").intValue()";
            case "uint32":
                return "((Number)" + expr + ").longValue()";
            case "int64":
                return "((Number)" + expr + ").longValue()";
            case "uint64":
                return "(BigInteger)" + expr;
            case "float32":
                return "((Number)" + expr + ").floatValue()";
            case "float64":
                return "((Number)" + expr + ").doubleValue()";
            case "bool":
                return "((Boolean)" + expr + ").booleanValue()";
            case "char8":
            case "char16":
            case "char32":
                return "((Character)" + expr + ").charValue()";
            case "string8":
            case "string16":
            case "string32":
                return "(String)" + expr;
            case "callable":
                return "(metaffi.api.accessor.Caller)" + expr;
            case "null":
                return "(Object)" + expr;
            case "handle":
            case "any":
                return "(" + javaType + ")" + expr;
            case "size":
                return "((Number)" + expr + ").longValue()";
            default:
                return "(" + javaType + ")" + expr;
        }
    }

    private String normalizeBaseType(String type) {
        if (type == null || type.isEmpty()) {
            return type;
        }
        if (type.endsWith("_array")) {
            return type.substring(0, type.length() - 6);
        }
        return type;
    }

    private int normalizeDimensions(String type, int dims) {
        if (type != null && type.endsWith("_array") && dims == 0) {
            return 1;
        }
        return dims;
    }

    private String getReturnType(List<ArgDefinition> retvals, String outerClassName,
                                 Set<String> wrapperClassNames, List<String> wrapperClasses,
                                 String ownerClassName, String callableName) {
        if (retvals == null || retvals.isEmpty()) {
            return "void";
        }
        if (retvals.size() == 1) {
            ArgDefinition rv = retvals.get(0);
            return mapToJavaType(rv.getType(), rv.getDimensions(), rv.getTypeAlias());
        }

        String wrapperName = buildWrapperName(ownerClassName, callableName);
        if (!wrapperClassNames.contains(wrapperName)) {
            wrapperClassNames.add(wrapperName);
            wrapperClasses.add(buildWrapperClass(wrapperName, retvals));
        }
        return outerClassName + "." + wrapperName;
    }

    private String buildWrapperClass(String wrapperName, List<ArgDefinition> retvals) {
        StringBuilder sb = new StringBuilder();
        appendLine(sb, 0, "public static class " + wrapperName + " {");
        for (ArgDefinition rv : retvals) {
            String type = mapToJavaType(rv.getType(), rv.getDimensions(), rv.getTypeAlias());
            appendLine(sb, 1, "public final " + type + " " + rv.getName() + ";");
        }
        appendLine(sb, 0, "");
        appendLine(sb, 1, "public " + wrapperName + "(" + buildParamSignature(retvals, 0) + ") {");
        for (ArgDefinition rv : retvals) {
            appendLine(sb, 2, "this." + rv.getName() + " = " + rv.getName() + ";");
        }
        appendLine(sb, 1, "}");
        appendLine(sb, 0, "}");
        return sb.toString();
    }

    private String buildWrapperName(String ownerClassName, String callableName) {
        if (ownerClassName != null && !ownerClassName.isEmpty()) {
            return ownerClassName + "_" + callableName + "Result";
        }
        return callableName + "Result";
    }

    private String buildParamSignature(List<ArgDefinition> params, int startIndex) {
        if (params == null || params.isEmpty() || startIndex >= params.size()) {
            return "";
        }
        List<String> parts = new ArrayList<>();
        for (int i = startIndex; i < params.size(); i++) {
            ArgDefinition p = params.get(i);
            String type = mapToJavaParamType(p);
            parts.add(type + " " + p.getName());
        }
        return String.join(", ", parts);
    }

    private String buildCallerArgs(List<ArgDefinition> params, int startIndex, boolean instanceRequired) {
        List<String> args = new ArrayList<>();
        if (instanceRequired) {
            args.add("this.handle");
        }
        if (params != null) {
            for (int i = startIndex; i < params.size(); i++) {
                args.add(params.get(i).getName());
            }
        }
        return String.join(", ", args);
    }
    private void appendOptionalOverloads(StringBuilder sb, String methodName, List<ArgDefinition> params, int startIndex,
                                         String returnType, String outerClassName, boolean isStatic) {
        appendOptionalOverloads(sb, methodName, params, startIndex, returnType, outerClassName, isStatic, 1);
    }

    private void appendOptionalOverloads(StringBuilder sb, String methodName, List<ArgDefinition> params, int startIndex,
                                         String returnType, String outerClassName, boolean isStatic, int indentLevel) {
        int firstOptional = findFirstOptionalIndex(params, startIndex);
        if (firstOptional == -1) {
            return;
        }

        for (int omitIndex = firstOptional; omitIndex < params.size(); omitIndex++) {
            String paramsSig = buildParamSignature(params, startIndex, omitIndex);
            appendLine(sb, indentLevel, (isStatic ? "public static " : "public ") + returnType + " " + methodName + "(" + paramsSig + ") {");
            String call = buildOverloadCall(methodName, params, startIndex, omitIndex);
            if ("void".equals(returnType)) {
                appendLine(sb, indentLevel + 1, call + ";");
                appendLine(sb, indentLevel, "}");
            } else {
                appendLine(sb, indentLevel + 1, "return " + call + ";");
                appendLine(sb, indentLevel, "}");
            }
        }
    }

    private int findFirstOptionalIndex(List<ArgDefinition> params, int startIndex) {
        if (params == null) {
            return -1;
        }
        for (int i = startIndex; i < params.size(); i++) {
            if (params.get(i).isOptional()) {
                return i;
            }
        }
        return -1;
    }

    private String buildParamSignature(List<ArgDefinition> params, int startIndex, int endExclusive) {
        if (params == null || params.isEmpty() || startIndex >= endExclusive) {
            return "";
        }
        List<String> parts = new ArrayList<>();
        for (int i = startIndex; i < endExclusive; i++) {
            ArgDefinition p = params.get(i);
            String type = mapToJavaParamType(p);
            parts.add(type + " " + p.getName());
        }
        return String.join(", ", parts);
    }

    private String buildOverloadCall(String methodName, List<ArgDefinition> params, int startIndex, int omitIndex) {
        List<String> args = new ArrayList<>();
        for (int i = startIndex; i < params.size(); i++) {
            if (i < omitIndex) {
                args.add(params.get(i).getName());
            } else {
                args.add("null");
            }
        }
        return methodName + "(" + String.join(", ", args) + ")";
    }

    private String mapToJavaType(String type, int dimensions, String typeAlias) {
        if (type == null || type.isEmpty()) {
            throw new CompilerException("Missing MetaFFI type");
        }

        String baseType = type;
        int dims = dimensions;
        if (type.endsWith("_array")) {
            baseType = type.substring(0, type.length() - 6);
            if (dims == 0) {
                dims = 1;
            }
        }

        String javaType;
        switch (baseType) {
            case "int8": javaType = "byte"; break;
            case "int16": javaType = "short"; break;
            case "int32": javaType = "int"; break;
            case "int64": javaType = "long"; break;
            case "uint8": javaType = "short"; break;
            case "uint16": javaType = "int"; break;
            case "uint32": javaType = "long"; break;
            case "uint64": javaType = "BigInteger"; break;
            case "float32": javaType = "float"; break;
            case "float64": javaType = "double"; break;
            case "bool": javaType = "boolean"; break;
            case "char8":
            case "char16":
            case "char32":
                javaType = "char"; break;
            case "string8":
            case "string16":
            case "string32":
                javaType = "String"; break;
            case "handle":
                javaType = resolveHandleAlias(typeAlias); break;
            case "any":
                javaType = "Object"; break;
            case "size":
                javaType = "long"; break;
            case "callable":
                javaType = "metaffi.api.accessor.Caller"; break;
            case "null":
                javaType = "Object"; break;
            default:
                throw new CompilerException("Unsupported MetaFFI type for Java: " + baseType);
        }

        if (dims > 0) {
            StringBuilder sb = new StringBuilder(javaType);
            for (int i = 0; i < dims; i++) {
                sb.append("[]");
            }
            return sb.toString();
        }
        return javaType;
    }

    private String mapToJavaParamType(ArgDefinition arg) {
        String baseType = mapToJavaType(arg.getType(), arg.getDimensions(), arg.getTypeAlias());
        if (!arg.isOptional()) {
            return baseType;
        }
        if (baseType.endsWith("[]")) {
            return baseType;
        }
        switch (baseType) {
            case "byte": return "Byte";
            case "short": return "Short";
            case "int": return "Integer";
            case "long": return "Long";
            case "float": return "Float";
            case "double": return "Double";
            case "boolean": return "Boolean";
            case "char": return "Character";
            default: return baseType;
        }
    }

    private String resolveHandleAlias(String typeAlias) {
        if (typeAlias == null || typeAlias.isEmpty()) {
            return "Object";
        }
        if (isValidJavaQualifiedName(typeAlias)) {
            return typeAlias;
        }
        return "Object";
    }

    private boolean isValidJavaQualifiedName(String name) {
        String[] parts = name.split("\\.");
        if (parts.length == 0) {
            return false;
        }
        for (String part : parts) {
            if (!isValidJavaIdentifier(part)) {
                return false;
            }
        }
        return true;
    }

    private boolean isValidJavaIdentifier(String name) {
        if (name == null || name.isEmpty()) {
            return false;
        }
        if (JAVA_KEYWORDS.contains(name)) {
            return false;
        }
        if (!Character.isJavaIdentifierStart(name.charAt(0))) {
            return false;
        }
        for (int i = 1; i < name.length(); i++) {
            if (!Character.isJavaIdentifierPart(name.charAt(i))) {
                return false;
            }
        }
        return true;
    }

    private String toPascalCase(String name) {
        if (name == null || name.isEmpty()) {
            return name;
        }
        if (name.length() == 1) {
            return name.toUpperCase();
        }
        return Character.toUpperCase(name.charAt(0)) + name.substring(1);
    }

    private String callerName(String base, String suffix) {
        return base + suffix;
    }

    private void appendJavaDoc(StringBuilder sb, int indentLevel, String comment, String fallback) {
        String text = (comment == null || comment.isEmpty()) ? fallback : comment;
        appendLine(sb, indentLevel, "/**");
        appendLine(sb, indentLevel, " * " + text.replace("\n", " "));
        appendLine(sb, indentLevel, " */");
    }

    private void appendLine(StringBuilder sb, int indentLevel, String line) {
        sb.append(indent(indentLevel)).append(line).append("\n");
    }

    private String indent(int level) {
        return "    ".repeat(Math.max(0, level));
    }

    private String escapeJava(String value) {
        return value.replace("\\", "\\\\").replace("\"", "\\\"");
    }

    private static final Set<String> JAVA_KEYWORDS = new HashSet<>();
    static {
        String[] keywords = new String[]{
            "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class",
            "const", "continue", "default", "do", "double", "else", "enum", "extends", "final",
            "finally", "float", "for", "goto", "if", "implements", "import", "instanceof", "int",
            "interface", "long", "native", "new", "package", "private", "protected", "public", "return",
            "short", "static", "strictfp", "super", "switch", "synchronized", "this", "throw", "throws",
            "transient", "try", "void", "volatile", "while", "true", "false", "null"
        };
        for (String kw : keywords) {
            JAVA_KEYWORDS.add(kw);
        }
    }
}
